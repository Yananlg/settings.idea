<application>
  <component name="AppStorage">
    <histories>
      <item value="Value that indicates that only properties with non-null values are to be included." />
      <item value="Specifies a reference to the corresponding type definition, overrides any other metadata specified" />
      <item value="An array of the sub types inheriting from this model." />
      <item value="This is the name of the field used as a discriminator. Based on this field, it would be possible to assert which sub type needs to be used." />
      <item value="upports model inheritance and polymorphism." />
      <item value="Classes will be introspected automatically as they are used as types in operations, but you may want to manipulate the structure of the models." />
      <item value="For backward compatibility" />
      <item value="Specifies a reference to the response type. The specified reference can be either local or remote and will be used as-is, and will override any specified response() class." />
      <item value="It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally." />
      <item value="Number formats are generally not synchronized." />
      <item value="literal" />
      <item value="when used in pipeline / transaction" />
      <item value="Set a specific leeway window in seconds in which the Not Before (&quot;nbf&quot;) Claim will still be valid. Not Before Date is always verified when the value is present. This method overrides the value set with acceptLeeway" />
      <item value="Define the default window in seconds in which the Not Before, Issued At and Expires At Claims will still be valid. Setting a specific leeway value on a given Claim will override this value for that Claim." />
      <item value="if leeway is negative." />
      <item value="the window in seconds in which the Expires At Claim will still be valid." />
      <item value="Expiration Date is always verified when the value is present. This method overrides the value set with acceptLeeway" />
      <item value="et a specific leeway window in seconds in which the Expires At (&quot;exp&quot;) Claim will still be valid." />
      <item value="Require a specific JWT Id (&quot;jti&quot;) claim." />
      <item value="Add a specific Not Before (&quot;nbf&quot;) claim to the Payload." />
      <item value="Audience" />
      <item value="Add a specific Subject (&quot;sub&quot;) claim to the Payload." />
      <item value="Add a specific Issuer (&quot;iss&quot;) claim to the Payload." />
      <item value="Datatype-specific additional piece of configuration that may be used to further refine formatting aspects. This may, for example, determine low-level format String used for {@link java.util.Date} serialization; however, exact use is determined by specific &lt;code&gt;JsonSerializer&lt;/code&gt;" />
      <item value="indicates" />
      <item value="Value that indicates shape should not be structural" />
      <item value="representing" />
      <item value="localprep" />
      <item value="Request subscription to recipient's presence" />
      <item value="subscription" />
      <item value="available" />
      <item value="presence" />
      <item value="Custom servers are possible, but not supported by the community. Please use our &lt;a href=&quot;https://github.com/openzipkin/zipkin#quick-start&quot;&gt;default server build&lt;/a&gt; first. If you find something missing, please &lt;a href=&quot;https://gitter.im/openzipkin/zipkin&quot;&gt;gitter&lt;/a&gt; us about it before making a custom server. If you decide to make a custom server, you accept responsibility for troubleshooting your build or configuration problems, even if such problems are a reaction to a change made by the OpenZipkin maintainers. In other words, custom servers are possible, but not supported." />
      <item value="If the property is not contained in the {@link Environment} at all, the {@link #matchIfMissing()} attribute is consulted. By default missing attributes do not match." />
      <item value="It is better to use a custom condition for such cases." />
      <item value="Consider defining a bean of type 'org.springframework.scheduling.TaskScheduler' in your configuration." />
      <item value="This conditional is intentionally not in an autoconfig (usually a bad idea) because // it is used to detect a BindingService in the parent context (which we know // already exists)." />
      <item value="Indicates whether or not this instance should register its information with eureka server for discovery by others. In some cases, you do not want your instances to be discovered whereas you just want do discover other instances." />
      <item value="is Access Token Expired" />
      <item value="Remaining time to live of Redisson object that has a timeout" />
      <item value="Get the time to live for {@code key} in seconds." />
      <item value="weixin info" />
      <item value="asynchronous" />
      <item value="object that prepares the request" />
      <item value="object that extracts the return value from the response" />
      <item value="/ The response type of the operation. In JAX-RS applications, the return type of the method would automatically be used, unless it is {@code javax.ws.rs.core.Response}. In that case, the operation return type would default to `void` as the actual response type cannot be known. Setting this property would override any automatically-derived data type. If the value used is a class representing a primitive ({@code Integer}, {@code Long}, ...) the corresponding primitive type will be used. /" />
      <item value="decode online" />
      <item value="Wrap an object, if necessary. If the object is null, return the NULL object. If it is an array or collection, wrap it in a JSONArray. If it is a map, wrap it in a JSONObject. If it is a standard property (Double, String, et al) then it is already wrapped. Otherwise, if it comes from one of the java packages, turn it into a string. And if it doesn't, try to wrap it in a JSONObject. If the wrapping fails, then null is returned." />
      <item value="Creates a new decompressor. If the parameter 'nowrap' is true then the ZLIB header and checksum fields will not be used. This provides compatibility with the compression format used by both GZIP and PKZIP. Note: When using the 'nowrap' option it is also necessary to provide an extra &quot;dummy&quot; byte as input. This is required by the ZLIB native library in order to support certain optimizations. @param nowrap if true then support GZIP compatible compression" />
      <item value="Creates a new decompressor. If the parameter 'nowrap' is true then the ZLIB header and checksum fields will not be used. This provides compatibility with the compression format used by both GZIP and PKZIP. Note: When using the 'nowrap' option it is also necessary to provide an extra &quot;dummy&quot; byte as input. This is required by the ZLIB native library in order to support certain optimizations." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="53" />
        <entry key="ENGLISH" value="54" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="foldOriginal" value="true" />
    <option name="ignoreRegExp" value="[\*]|(&lt;p&gt;)" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Source Code Pro" />
    <option name="primaryFontFamily" value="Microsoft YaHei" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="0b9675ec9310c20e" />
      </youdao-translate>
    </option>
  </component>
</application>