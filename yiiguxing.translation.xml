<application>
  <component name="AppStorage">
    <histories>
      <item value="After it is closed it is not possible to reuse it again." />
      <item value="Request to close the {@link Channel} and notify the {@link ChannelFuture} once the operation completes, either because the operation was successful or because of an error." />
      <item value="The annotation used to declare a listener for various types of event, in a given web application context.&lt;br&gt; &lt;br&gt; The class annotated MUST implement one, (or more), of the following interfaces: {@link javax.servlet.http.HttpSessionAttributeListener}," />
      <item value="The PreDestroy annotation is used on methods as a callback notification to signal that the instance is in the process of being removed by the container. The method annotated with PreDestroy is typically used to release resources that it has been holding. This annotation MUST be supported by all container managed objects that support PostConstruct except the application client container in Java EE 5. The method on which the PreDestroy annotation is applied MUST fulfill all of the following criteria: &lt;ul&gt; &lt;li&gt;The method MUST NOT have any parameters except in the case of interceptors in which case it takes an InvocationContext object as defined by the Interceptors specification.&lt;/li&gt; &lt;li&gt;The method defined on an interceptor class MUST HAVE one of the following signatures: void &amp;#060;METHOD&amp;#062;(InvocationContext) Object &amp;#060;METHOD&amp;#062;(InvocationContext) throws Exception &lt;i&gt;Note: A PreDestroy interceptor method must not throw application exceptions, but it may be declared to throw checked exceptions including the java.lang.Exception if the same interceptor method interposes on business or timeout methods in addition to lifecycle events. If a PreDestroy interceptor method returns a value, it is ignored by the container.&lt;/i&gt; &lt;/li&gt; &lt;li&gt;The method defined on a non-interceptor class MUST HAVE the following signature: void &amp;#060;METHOD&amp;#062;() &lt;/li&gt; &lt;li&gt;The method on which PreDestroy is applied MAY be public, protected, package private or private.&lt;/li&gt; &lt;li&gt;The method MUST NOT be static.&lt;/li&gt; &lt;li&gt;The method MAY be final.&lt;/li&gt; &lt;li&gt;If the method throws an unchecked exception it is ignored except in the case of EJBs where the EJB can handle exceptions.&lt;/li&gt; &lt;/ul&gt;" />
      <item value="Creates the directory named by this abstract pathname, including any necessary but nonexistent parent directories. Note that if this operation fails it may have succeeded in creating some of the necessary parent directories." />
      <item value="includes" />
      <item value="consumed" />
      <item value="Producer" />
      <item value="the position of this API in the resource listing, no longer used." />
      <item value="enter" />
      <item value="NAMESRV ADD Rhttp" />
      <item value="the class (or interface) to restrict property setting to" />
      <item value="add Using POST_11" />
      <item value="unallocated" />
      <item value="The byte value to use in padding the data" />
      <item value="truncated" />
      <item value="a negative integer, zero, or a positive integer as the first" />
      <item value="Determines how two dates compare up to no more than the specified most significant field." />
      <item value="The annotated element must be an instant, date or time in the future." />
      <item value="the array into which the elements of this list are to be stored, if it is big enough; otherwise, a new array of the same runtime type is allocated for this purpose." />
      <item value="URI or URI-template that the annotated class should be mapped to. @return The URI or URI-template that the annotated class should be mapped" />
      <item value="value(key)" />
      <item value="reserved for international and undocumented" />
      <item value="Returns the underlying source used to find the home directory. This is usually the jar file or a directory. Can return {@code null} if the source cannot be determined." />
      <item value="Valid" />
      <item value="Nominal type supported, usually declared type of property for which serializer is used." />
      <item value="Method for accessing type of Objects this serializer can handle. Note that this information is not guaranteed to be exact -- it may be a more generic (super-type) -- but it should not be incorrect (return a non-related type). Default implementation will return null, which essentially means same as returning &lt;code&gt;Object.class&lt;/code&gt; would; that is, that nothing is known about handled type." />
      <item value="Note: if {@link #using} is also used it has precedence (since it directly specifies serializer, whereas this would only be used to locate the serializer) and value of this annotation property is ignored." />
      <item value="Supertype (of declared type, which itself is supertype of runtime type) to use as type when locating serializer to use." />
      <item value="Serializer class to use for serializing Map keys of annotated property. Can only be used on properties (methods, fields, constructors), and not value classes themselves." />
      <item value="Serializer class to use for serializing contents (elements of a Collection/array, values of Maps) of annotated property. Can only be used on properties (methods, fields, constructors), and not value classes themselves (as they are typically generic)" />
      <item value="Serializer class to use for serializing associated value. Depending on what is annotated, value is either an instance of annotated class (used globablly anywhere where class serializer is needed); or only used for serializing property access via a getter method." />
      <item value="Base class that defines public API for writing JSON content. Instances are created using factory methods of" />
      <item value="with" />
      <item value="annotation.get Class()" />
      <item value="Constraint" />
      <item value="Indicates that the persistence provider should pick an appropriate strategy for the particular database. The &lt;code&gt;AUTO&lt;/code&gt; generation strategy may expect a database resource to exist, or it may attempt to create one. A vendor may provide documentation on how to create such resources in the event that it does not support schema generation or cannot create the schema resource at runtime." />
      <item value="Indicates that the persistence provider must assign primary keys for the entity using database identity column." />
      <item value="Indicates that the persistence provider must assign primary keys for the entity using database sequence column." />
      <item value="Indicates that the persistence provider must assign primary keys for the entity using an underlying database table to ensure uniqueness." />
      <item value="delete" />
      <item value="scale" />
      <item value="Default implementation will write type prefix, call regular serialization method (since assumption is that value itself does not need JSON Array or Object start/end markers), and then write type suffix. This should work for most cases; some sub-classes may want to change this behavior." />
      <item value="Alternate constructor that is (alas!) needed to work around kinks of generic type handling" />
      <item value="Serialization method called when no additional type information is to be included in serialization." />
      <item value="Set of attribute-backed properties to include when serializing a POJO." />
      <item value="Annotation that may be used to add &quot;virtual&quot; properties to be written after regular properties (although ordering may be changed using both standard &lt;code&gt;@JsonPropertyOrder&lt;/code&gt; annotation, and properties of this annotation)." />
      <item value="Specifies whether or not to attach the artifact to the project" />
      <item value="Specifies whether the Javadoc generation should be skipped" />
      <item value="Sets the unformatted argument string to be passed to test compiler if fork is set to true." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="199" />
        <entry key="ENGLISH" value="200" />
        <entry key="GERMAN" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190222000270023" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="foldOriginal" value="true" />
    <option name="ignoreRegExp" value="[\*]|(&lt;p&gt;)" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Source Code Pro" />
    <option name="primaryFontFamily" value="Microsoft YaHei" />
    <option name="translator" value="fanyi.baidu" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="0b9675ec9310c20e" />
      </youdao-translate>
    </option>
  </component>
</application>