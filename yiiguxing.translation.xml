<application>
  <component name="AppStorage">
    <histories>
      <item value="docket" />
      <item value="Annotation to enable JPA repositories. Will scan the package of the annotated configuration class for Spring Data repositories by default." />
      <item value="Bean post processor for Spring that automatically calls the &lt;tt&gt;init()&lt;/tt&gt; and/or &lt;tt&gt;destroy()&lt;/tt&gt; methods on Shiro objects that implement the {@link org.apache.shiro.util.Initializable} or {@link org.apache.shiro.util.Destroyable} interfaces, respectfully. This post processor makes it easier to configure Shiro beans in Spring, since the user never has to worry about whether or not if they have to specify init-method and destroy-method bean attributes.&lt;/p&gt;" />
      <item value="The value may indicate a suggestion for a logical component name, to be turned into a Spring bean in case of an autodetected component. @return the suggested component name, if any (or empty String otherwise)" />
      <item value="Filter that allows access if the current user has the permissions specified by the mapped value, or denies access if the user does not have all of the permissions specified." />
      <item value="if this current instance &lt;em&gt;implies&lt;/em&gt; all the functionality and/or resource access" />
      <item value="Returns {@code true} if this current instance &lt;em&gt;implies&lt;/em&gt; all the functionality and/or resource access described by the specified {@code Permission} argument, {@code false} otherwise." />
      <item value="Always returns &lt;tt&gt;true&lt;/tt&gt;, indicating any Subject granted this permission can do anything." />
      <item value="implies" />
      <item value="Returns an account's authorization-specific information for the specified {@code principals}, or {@code null} if no account could be found. The resulting {@code AuthorizationInfo} object is used by the other method implementations in this class to automatically perform access control checks for the corresponding {@code Subject}. &lt;p/&gt; This implementation obtains the actual {@code AuthorizationInfo} object from the subclass's implementation of {@link #doGetAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection) doGetAuthorizationInfo}, and then caches it for efficient reuse if caching is enabled (see below). &lt;p/&gt; Invocations of this method should be thought of as completely orthogonal to acquiring {@link #getAuthenticationInfo(org.apache.shiro.authc.AuthenticationToken) authenticationInfo}, since either could occur in any order. &lt;p/&gt; For example, in &amp;quot;Remember Me&amp;quot; scenarios, the user identity is remembered (and assumed) for their current session and an authentication attempt during that session might never occur. But because their identity would be remembered, that is sufficient enough information to call this method to execute any necessary authorization checks. For this reason, authentication and authorization should be loosely coupled and not depend on each other. &lt;h3&gt;Caching&lt;/h3&gt; The {@code AuthorizationInfo} values returned from this method are cached for efficient reuse if caching is enabled. Caching is enabled automatically when an {@link #setAuthorizationCache authorizationCache} instance has been explicitly configured, or if a {@link #setCacheManager cacheManager} has been configured, which will be used to lazily create the {@code authorizationCache} as needed. &lt;p/&gt; If caching is enabled, the authorization cache will be checked first and if found, will return the cached {@code AuthorizationInfo} immediately. If caching is disabled, or there is a cache miss, the authorization info will be looked up from the underlying data store via the {@link #doGetAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection)} method, which must be implemented by subclasses. &lt;h4&gt;Changed Data&lt;/h4&gt; If caching is enabled and if any authorization data for an account is changed at runtime, such as adding or removing roles and/or permissions, the subclass implementation should clear the cached AuthorizationInfo for that account via the {@link #clearCachedAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection) clearCachedAuthorizationInfo} method. This ensures that the next call to {@code getAuthorizationInfo(PrincipalCollection)} will acquire the account's fresh authorization data, where it will then be cached for efficient reuse. This ensures that stale authorization data will not be reused." />
      <item value="Treats strings as regular expression patterns" />
      <item value="Matches string containing pattern" />
      <item value="Matches string ending with pattern" />
      <item value="Matches string starting with pattern" />
      <item value="Matches the exact string" />
      <item value="the class (or interface) to restrict property setting to" />
      <item value="Request to deregister from the previous assigned {@link EventExecutor} and notify the {@link ChannelFuture} once the operation completes, either because the operation was successful or because of an error." />
      <item value="After it is closed it is not possible to reuse it again." />
      <item value="Request to close the {@link Channel} and notify the {@link ChannelFuture} once the operation completes, either because the operation was successful or because of an error." />
      <item value="The annotation used to declare a listener for various types of event, in a given web application context.&lt;br&gt; &lt;br&gt; The class annotated MUST implement one, (or more), of the following interfaces: {@link javax.servlet.http.HttpSessionAttributeListener}," />
      <item value="The PreDestroy annotation is used on methods as a callback notification to signal that the instance is in the process of being removed by the container. The method annotated with PreDestroy is typically used to release resources that it has been holding. This annotation MUST be supported by all container managed objects that support PostConstruct except the application client container in Java EE 5. The method on which the PreDestroy annotation is applied MUST fulfill all of the following criteria: &lt;ul&gt; &lt;li&gt;The method MUST NOT have any parameters except in the case of interceptors in which case it takes an InvocationContext object as defined by the Interceptors specification.&lt;/li&gt; &lt;li&gt;The method defined on an interceptor class MUST HAVE one of the following signatures: void &amp;#060;METHOD&amp;#062;(InvocationContext) Object &amp;#060;METHOD&amp;#062;(InvocationContext) throws Exception &lt;i&gt;Note: A PreDestroy interceptor method must not throw application exceptions, but it may be declared to throw checked exceptions including the java.lang.Exception if the same interceptor method interposes on business or timeout methods in addition to lifecycle events. If a PreDestroy interceptor method returns a value, it is ignored by the container.&lt;/i&gt; &lt;/li&gt; &lt;li&gt;The method defined on a non-interceptor class MUST HAVE the following signature: void &amp;#060;METHOD&amp;#062;() &lt;/li&gt; &lt;li&gt;The method on which PreDestroy is applied MAY be public, protected, package private or private.&lt;/li&gt; &lt;li&gt;The method MUST NOT be static.&lt;/li&gt; &lt;li&gt;The method MAY be final.&lt;/li&gt; &lt;li&gt;If the method throws an unchecked exception it is ignored except in the case of EJBs where the EJB can handle exceptions.&lt;/li&gt; &lt;/ul&gt;" />
      <item value="Creates the directory named by this abstract pathname, including any necessary but nonexistent parent directories. Note that if this operation fails it may have succeeded in creating some of the necessary parent directories." />
      <item value="includes" />
      <item value="consumed" />
      <item value="Producer" />
      <item value="the position of this API in the resource listing, no longer used." />
      <item value="enter" />
      <item value="NAMESRV ADD Rhttp" />
      <item value="add Using POST_11" />
      <item value="unallocated" />
      <item value="The byte value to use in padding the data" />
      <item value="truncated" />
      <item value="a negative integer, zero, or a positive integer as the first" />
      <item value="Determines how two dates compare up to no more than the specified most significant field." />
      <item value="The annotated element must be an instant, date or time in the future." />
      <item value="the array into which the elements of this list are to be stored, if it is big enough; otherwise, a new array of the same runtime type is allocated for this purpose." />
      <item value="URI or URI-template that the annotated class should be mapped to. @return The URI or URI-template that the annotated class should be mapped" />
      <item value="value(key)" />
      <item value="reserved for international and undocumented" />
      <item value="Returns the underlying source used to find the home directory. This is usually the jar file or a directory. Can return {@code null} if the source cannot be determined." />
      <item value="Valid" />
      <item value="Nominal type supported, usually declared type of property for which serializer is used." />
      <item value="Method for accessing type of Objects this serializer can handle. Note that this information is not guaranteed to be exact -- it may be a more generic (super-type) -- but it should not be incorrect (return a non-related type). Default implementation will return null, which essentially means same as returning &lt;code&gt;Object.class&lt;/code&gt; would; that is, that nothing is known about handled type." />
      <item value="Note: if {@link #using} is also used it has precedence (since it directly specifies serializer, whereas this would only be used to locate the serializer) and value of this annotation property is ignored." />
      <item value="Supertype (of declared type, which itself is supertype of runtime type) to use as type when locating serializer to use." />
      <item value="Serializer class to use for serializing Map keys of annotated property. Can only be used on properties (methods, fields, constructors), and not value classes themselves." />
      <item value="Serializer class to use for serializing contents (elements of a Collection/array, values of Maps) of annotated property. Can only be used on properties (methods, fields, constructors), and not value classes themselves (as they are typically generic)" />
      <item value="Serializer class to use for serializing associated value. Depending on what is annotated, value is either an instance of annotated class (used globablly anywhere where class serializer is needed); or only used for serializing property access via a getter method." />
      <item value="Base class that defines public API for writing JSON content. Instances are created using factory methods of" />
      <item value="with" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="216" />
        <entry key="ENGLISH" value="217" />
        <entry key="GERMAN" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190222000270023" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="foldOriginal" value="true" />
    <option name="ignoreRegExp" value="[\*]|(&lt;p&gt;)" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Source Code Pro" />
    <option name="primaryFontFamily" value="Microsoft YaHei" />
    <option name="translator" value="fanyi.baidu" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="0b9675ec9310c20e" />
      </youdao-translate>
    </option>
  </component>
</application>