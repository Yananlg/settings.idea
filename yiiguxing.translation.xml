<application>
  <component name="AppStorage">
    <histories>
      <item value="Indicates that the persistence provider should pick an appropriate strategy for the particular database. The &lt;code&gt;AUTO&lt;/code&gt; generation strategy may expect a database resource to exist, or it may attempt to create one. A vendor may provide documentation on how to create such resources in the event that it does not support schema generation or cannot create the schema resource at runtime." />
      <item value="Indicates that the persistence provider must assign primary keys for the entity using database identity column." />
      <item value="Indicates that the persistence provider must assign primary keys for the entity using database sequence column." />
      <item value="Indicates that the persistence provider must assign primary keys for the entity using an underlying database table to ensure uniqueness." />
      <item value="delete" />
      <item value="scale" />
      <item value="Default implementation will write type prefix, call regular serialization method (since assumption is that value itself does not need JSON Array or Object start/end markers), and then write type suffix. This should work for most cases; some sub-classes may want to change this behavior." />
      <item value="Alternate constructor that is (alas!) needed to work around kinks of generic type handling" />
      <item value="Serialization method called when no additional type information is to be included in serialization." />
      <item value="Set of attribute-backed properties to include when serializing a POJO." />
      <item value="Annotation that may be used to add &quot;virtual&quot; properties to be written after regular properties (although ordering may be changed using both standard &lt;code&gt;@JsonPropertyOrder&lt;/code&gt; annotation, and properties of this annotation)." />
      <item value="Specifies whether or not to attach the artifact to the project" />
      <item value="Specifies whether the Javadoc generation should be skipped" />
      <item value="Sets the unformatted argument string to be passed to test compiler if fork is set to true." />
      <item value="Set this to &amp;apos;true&amp;apos; to bypass compilation of test sources.&#10;Its use is NOT RECOMMENDED, but quite convenient on occasion." />
      <item value="Flag to indicate if the run processes should be forked. {@code fork} is&#10;automatically enabled if an agent, jvmArguments or working directory are specified,&#10;or if devtools is present." />
      <item value="Feature" />
      <item value="Returns this Subject's application-wide uniquely identifying principal, or {@code null} if this Subject is anonymous because it doesn't yet have any associated account data (for example, if they haven't logged in). &lt;p/&gt; The term &lt;em&gt;principal&lt;/em&gt; is just a fancy security term for any identifying attribute(s) of an application user, such as a username, or user id, or public key, or anything else you might use in your application to identify a user. &lt;h4&gt;Uniqueness&lt;/h4&gt; Although given names and family names (first/last) are technically considered principals as well, Shiro expects the object returned from this method to be an identifying attribute unique across your entire application. &lt;p/&gt; This implies that things like given names and family names are usually poor candidates as return values since they are rarely guaranteed to be unique; Things often used for this value:" />
      <item value="Exception thrown if there is a problem during authorization (access control check)." />
      <item value="Authorization FAIL" />
      <item value="General exception thrown due to an error during the Authentication process." />
      <item value="Exception thrown due to a problem with the credential(s) submitted for an account during the authentication process." />
      <item value="Exception thrown due to a problem with the account under which an authentication attempt is being executed." />
      <item value="Exception wrapping any potential checked exception thrown when a {@code Subject} executes a {@link java.util.concurrent.Callable}. This is a nicer alternative than forcing calling code to catch a normal checked {@code Exception} when it may not be necessary. &lt;p/&gt; If thrown, the causing exception will always be accessible via the {@link #getCause() getCause()} method." />
      <item value="Exception thrown when attempting to instantiate a Class via reflection, but a suitable constructor (depending on the number of expected arguments) doesn't exist or cannot be obtained." />
      <item value="Thrown by {@link PermissionResolver#resolvePermission(String)} when the String being parsed is not valid for that resolver." />
      <item value="Exception thrown when attempting to acquire the application's {@code SecurityManager} instance, but Shiro's lookup heuristics cannot find one. This typically indicates an invalid application configuration." />
      <item value="The logical operation for the permission check in case multiple roles are specified. AND is the default" />
      <item value="CONFLICT" />
      <item value="Attempts" />
      <item value="Excessive" />
      <item value="Invoked second (and last) if the body is empty." />
      <item value="increment" />
      <item value="the salt used when hashing the given hashedCredentials" />
      <item value="a Realm's account's identifying principal(s)" />
      <item value="Constructor that takes in an account's identifying principal(s) and its corresponding credentials that verify the principals." />
      <item value="the 'primary' principal associated with the specified realm." />
      <item value="the realm from where the principal and credentials were acquired." />
      <item value="monster" />
      <item value="ITERATIONS" />
      <item value="a fully-qualified class name." />
      <item value="Returns the interfaces implemented by this service provider" />
      <item value="Creates a new auxiliary resource file for writing and returns a file object for it. The file may be located along with the newly created source files, newly created binary files, or other supported location. The locations {@link StandardLocation#CLASS_OUTPUT CLASS_OUTPUT} and {@link StandardLocation#SOURCE_OUTPUT SOURCE_OUTPUT} must be supported. The resource may be named relative to some package (as are source and class files), and from there by a relative pathname. In a loose sense, the full pathname of the new file will be the concatenation of {@code location}, {@code pkg}, and {@code relativeName}." />
      <item value="Creates a new source file and returns an object to allow writing to it. The file's name and path (relative to the {@linkplain StandardLocation#SOURCE_OUTPUT root output location for source files}) are based on the type to be declared in that file. If more than one type is being declared, the name of the principal top-level type (the public one, for example) should be used. A source file can also be created to hold information about a package, including package annotations. To create a source file for a named package, have {@code name} be the package's name followed by {@code &quot;.package-info&quot;}; to create a source file for an unnamed package, use {@code &quot;package-info&quot;}." />
      <item value="Returns an implementation of some utility methods for operating on types." />
      <item value="Returns the messager used to report errors, warnings, and other notices." />
      <item value="Returns the processor-specific options passed to the annotation processing tool. Options are returned in the form of a map from option name to option value. For an option with no value, the corresponding value in the map is {@code null}." />
      <item value="Returns the filer used to create new source, class, or auxiliary files." />
      <item value="Returns an implementation of some utility methods for operating on elements" />
      <item value="Determines the interfaces implemented by the class or interface represented by this object." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="164" />
        <entry key="ENGLISH" value="165" />
        <entry key="GERMAN" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190222000270023" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="foldOriginal" value="true" />
    <option name="ignoreRegExp" value="[\*]|(&lt;p&gt;)" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Source Code Pro" />
    <option name="primaryFontFamily" value="Microsoft YaHei" />
    <option name="translator" value="fanyi.baidu" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="0b9675ec9310c20e" />
      </youdao-translate>
    </option>
  </component>
</application>