<application>
  <component name="AppStorage">
    <histories>
      <item value="account" />
      <item value="The name of the foreign key column. The table in which it is found depends upon the context." />
      <item value="The name of the column referenced by this foreign key column." />
      <item value="tinyint" />
      <item value="Cascade all operations" />
      <item value="Cascade persist operation" />
      <item value="Cascade merge operation" />
      <item value="Cascade remove operation" />
      <item value="Cascade refresh operation" />
      <item value="Cascade detach operation" />
      <item value="anon" />
      <item value="Increment an integer value stored as string value under {@code key} by {@code delta}." />
      <item value="a Map with the matching beans, containing the bean names as keys and the corresponding bean instances as values" />
      <item value="Modify the application context's internal bean factory after its standard initialization. All bean definitions will have been loaded, but no beans will have been instantiated yet. This allows for overriding or adding properties even to eager-initializing beans. @param beanFactory the bean factory used by the application context" />
      <item value="A list of tags for API documentation control. Tags can be used for logical grouping of operations by resources or any other qualifier. A non-empty value will override the value received from {@link Api#value()} or {@link Api#tags()} for this operation." />
      <item value="Corresponds to the 'notes' field of the operation. A verbose description of the operation." />
      <item value="Corresponds to the `summary` field of the operation. Provides a brief description of this operation. Should be 120 characters or less for proper visibility in Swagger-UI." />
      <item value="The annotation type {@code java.lang.annotation.Repeatable} is used to indicate that the annotation type whose declaration it (meta-)annotates is &lt;em&gt;repeatable&lt;/em&gt;. The value of {@code @Repeatable} indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the repeatable annotation type." />
      <item value="Amount of time before asynchronous request handling times out. If this value is not set, the default timeout of the underlying implementation is used, e.g. 10 seconds on Tomcat with Servlet 3." />
      <item value="the absolute path within the classpath" />
      <item value="Signed Url, which has the bucket name, object key, account information and accessed Ids and its signature. The url is recommended to be generated by generatePresignedUrl()." />
      <item value="The response type of the operation. In JAX-RS applications, the return type of the method would automatically be used, unless it is {@code javax.ws.rs.core.Response}. In that case, the operation return type would default to `void` as the actual response type cannot be known. Setting this property would override any automatically-derived data type. If the value used is a class representing a primitive ({@code Integer}, {@code Long}, ...) the corresponding primitive type will be used." />
      <item value="Declares a container wrapping the response. Valid values are &quot;List&quot;, &quot;Set&quot; or &quot;Map&quot;. Any other value will be ignored." />
      <item value="Specifies a reference to the response type. The specified reference can be either local or remote and will be used as-is, and will override any specified response() class." />
      <item value="left unbound" />
      <item value="left" />
      <item value="Modify the application context's internal bean definition registry after its standard initialization. All regular bean definitions will have been loaded, but no beans will have been instantiated yet. This allows for adding further bean definitions before the next post-processing phase kicks in." />
      <item value="Mark the start of a transaction block. &lt;br&gt; Commands will be queued and can then be executed by calling {@link #exec()} or rolled back using {@link #discard()}" />
      <item value="iterations" />
      <item value="algorithm" />
      <item value="auditor" />
      <item value="Interface for components that are aware of the application's current auditor. This will be some kind of user mostly." />
      <item value="Abstract base class for auditable entities. Stores the audition values in persistent fields." />
      <item value="the class of authentication token instances supported by this realm." />
      <item value="Unless overridden by this method, the default value is {@link org.apache.shiro.authc.UsernamePasswordToken UsernamePasswordToken.class} to support the majority of applications." />
      <item value="Sets the authenticationToken class supported by this realm." />
      <item value="Simple CredentialsMatcher implementation. Supports direct (plain) comparison for credentials of type byte[], char[], and Strings, and if the arguments do not match these types, then reverts back to simple &lt;code&gt;Object.equals&lt;/code&gt; comparison. &lt;p/&gt; Hashing comparisons (the most common technique used in secure applications) are not supported by this class, but instead by the {@link org.apache.shiro.authc.credential.HashedCredentialsMatcher HashedCredentialsMatcher}" />
      <item value="Authorization" />
      <item value="Authentication" />
      <item value="docket" />
      <item value="Annotation to enable JPA repositories. Will scan the package of the annotated configuration class for Spring Data repositories by default." />
      <item value="Bean post processor for Spring that automatically calls the &lt;tt&gt;init()&lt;/tt&gt; and/or &lt;tt&gt;destroy()&lt;/tt&gt; methods on Shiro objects that implement the {@link org.apache.shiro.util.Initializable} or {@link org.apache.shiro.util.Destroyable} interfaces, respectfully. This post processor makes it easier to configure Shiro beans in Spring, since the user never has to worry about whether or not if they have to specify init-method and destroy-method bean attributes.&lt;/p&gt;" />
      <item value="The value may indicate a suggestion for a logical component name, to be turned into a Spring bean in case of an autodetected component. @return the suggested component name, if any (or empty String otherwise)" />
      <item value="Filter that allows access if the current user has the permissions specified by the mapped value, or denies access if the user does not have all of the permissions specified." />
      <item value="if this current instance &lt;em&gt;implies&lt;/em&gt; all the functionality and/or resource access" />
      <item value="Returns {@code true} if this current instance &lt;em&gt;implies&lt;/em&gt; all the functionality and/or resource access described by the specified {@code Permission} argument, {@code false} otherwise." />
      <item value="Always returns &lt;tt&gt;true&lt;/tt&gt;, indicating any Subject granted this permission can do anything." />
      <item value="implies" />
      <item value="Returns an account's authorization-specific information for the specified {@code principals}, or {@code null} if no account could be found. The resulting {@code AuthorizationInfo} object is used by the other method implementations in this class to automatically perform access control checks for the corresponding {@code Subject}. &lt;p/&gt; This implementation obtains the actual {@code AuthorizationInfo} object from the subclass's implementation of {@link #doGetAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection) doGetAuthorizationInfo}, and then caches it for efficient reuse if caching is enabled (see below). &lt;p/&gt; Invocations of this method should be thought of as completely orthogonal to acquiring {@link #getAuthenticationInfo(org.apache.shiro.authc.AuthenticationToken) authenticationInfo}, since either could occur in any order. &lt;p/&gt; For example, in &amp;quot;Remember Me&amp;quot; scenarios, the user identity is remembered (and assumed) for their current session and an authentication attempt during that session might never occur. But because their identity would be remembered, that is sufficient enough information to call this method to execute any necessary authorization checks. For this reason, authentication and authorization should be loosely coupled and not depend on each other. &lt;h3&gt;Caching&lt;/h3&gt; The {@code AuthorizationInfo} values returned from this method are cached for efficient reuse if caching is enabled. Caching is enabled automatically when an {@link #setAuthorizationCache authorizationCache} instance has been explicitly configured, or if a {@link #setCacheManager cacheManager} has been configured, which will be used to lazily create the {@code authorizationCache} as needed. &lt;p/&gt; If caching is enabled, the authorization cache will be checked first and if found, will return the cached {@code AuthorizationInfo} immediately. If caching is disabled, or there is a cache miss, the authorization info will be looked up from the underlying data store via the {@link #doGetAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection)} method, which must be implemented by subclasses. &lt;h4&gt;Changed Data&lt;/h4&gt; If caching is enabled and if any authorization data for an account is changed at runtime, such as adding or removing roles and/or permissions, the subclass implementation should clear the cached AuthorizationInfo for that account via the {@link #clearCachedAuthorizationInfo(org.apache.shiro.subject.PrincipalCollection) clearCachedAuthorizationInfo} method. This ensures that the next call to {@code getAuthorizationInfo(PrincipalCollection)} will acquire the account's fresh authorization data, where it will then be cached for efficient reuse. This ensures that stale authorization data will not be reused." />
      <item value="Treats strings as regular expression patterns" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="255" />
        <entry key="ENGLISH" value="256" />
        <entry key="GERMAN" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190222000270023" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="foldOriginal" value="true" />
    <option name="ignoreRegExp" value="[\*]|(&lt;p&gt;)" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Source Code Pro" />
    <option name="primaryFontFamily" value="Microsoft YaHei" />
    <option name="translator" value="fanyi.baidu" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="0b9675ec9310c20e" />
      </youdao-translate>
    </option>
  </component>
</application>