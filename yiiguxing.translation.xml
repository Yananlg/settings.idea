<application>
  <component name="AppStorage">
    <histories>
      <item value="Specify whether or not datetime parsing is to be lenient. With lenient parsing, the parser may use heuristics to interpret inputs that do not precisely match this object's format. With strict parsing, inputs must match this object's format." />
      <item value="the exact expected length of the date String" />
      <item value="The classes that must be present. Since this annotation is parsed by loading class bytecode, it is safe to specify classes here that may ultimately not be on the classpath, only if this annotation is directly on the affected component and &lt;b&gt;not&lt;b&gt; if this annotation is used as a composed, meta-annotation. In order to use this annotation as a meta-annotation, only use the link #name attribute. return the classes that must be present" />
      <item value="The classes names that must be present." />
      <item value="rejected" />
      <item value="Whether user credentials are supported. &lt;p&gt;By default this is not set (i.e. user credentials are not supported)." />
      <item value="persist" />
      <item value="merge" />
      <item value="each" />
      <item value="sharding Value" />
      <item value="an optional array of extensions" />
      <item value="Limits the acceptable values for this parameter. &lt;p&gt; There are three ways to describe the allowable values: &lt;ol&gt; &lt;li&gt;To set a list of values, provide a comma-separated list. For example: code first, second, third.&lt;li&gt; &lt;li&gt;To set a range of values, start the value with &quot;range&quot;, and surrounding by square brackets include the minimum and maximum values, or round brackets for exclusive minimum and maximum values. For example: code range[1, 5], code range(1, 5), code range[1, 5).&lt;li&gt; &lt;li&gt;To set a minimummaximum value, use the same format for range but use &quot;infinity&quot; or &quot;-infinity&quot; as the second value. For example, code range[1, infinity] means the minimum allowable value of this parameter is 1.&lt;li&gt;" />
      <item value="Allows for filtering a property from the API documentation. See io.swagger.core.filter.SwaggerSpecFilter." />
      <item value="exclusive" />
      <item value="the next pseudorandom, uniformly distributed code int value between zero (inclusive) and code bound (exclusive)" />
      <item value="the position in set of chars to end before (exclusive)" />
      <item value="the position in set of chars to start at (inclusive)" />
      <item value="the set of chars to choose randoms from, must not be empty. If code null, then it will use the set of all chars." />
      <item value="only allow numbers" />
      <item value="only allow letters?" />
      <item value="Signed url, which has the bucket name, object key, account information and accessed Ids and its signature. The url is recommended to be generated by generatePresignedUrl()." />
      <item value="Uploads the file from a specified file path to the signed URL with specified headers" />
      <item value="The annotated element must be an instant, date or time in the past" />
      <item value="detach" />
      <item value="Creates a random string whose length is the number of characters specified" />
      <item value="commander" />
      <item value="Command" />
      <item value="Commond" />
      <item value="The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties." />
      <item value="&lt;p&gt;Like with any annotation in Java, the mere presence of code AliasFor on its own will not enforce alias semantics. For alias semantics to be enforced, annotations must be &lt;em&gt;loaded&lt;em&gt; via the utility methods in link AnnotationUtils. Behind the scenes, Spring will &lt;em&gt;synthesize&lt;em&gt; an annotation by wrapping it in a dynamic proxy that transparently enforces &lt;em&gt;attribute alias&lt;em&gt; semantics for annotation attributes that are annotated with code AliasFor. Similarly, link AnnotatedElementUtils supports explicit meta-annotation attribute overrides when code AliasFor is used within an annotation hierarchy. Typically you will not need to manually synthesize annotations on your own since Spring will do that for you transparently when looking up annotations on Spring-managed components." />
      <item value="Explicit aliases within an annotation&lt;strong&gt;: within a single annotation, code AliasFor can be declared on a pair of attributes to signal that they are interchangeable aliases for each other.&lt;li&gt; &lt;li&gt;&lt;strong&gt;Explicit alias for attribute in meta-annotation&lt;strong&gt;: if the link #annotation attribute of code AliasFor is set to a different annotation than the one that declares it, the link #attribute is interpreted as an alias for an attribute in a meta-annotation (i.e., an explicit meta-annotation attribute override). This enables fine-grained control over exactly which attributes are overridden within an annotation hierarchy. In fact, with code AliasFor it is even possible to declare an alias for the code value attribute of a meta-annotation.&lt;li&gt; &lt;li&gt;&lt;strong&gt;Implicit aliases within an annotation&lt;strong&gt;: if one or more attributes within an annotation are declared as attribute overrides for the same meta-annotation attribute (either directly or transitively), those attributes will be treated as a set of &lt;em&gt;implicit&lt;em&gt; aliases for each other, resulting in behavior analogous to that for explicit aliases within an annotation.&lt;li&gt;" />
      <item value="Fraction" />
      <item value="Digits" />
      <item value="Amount" />
      <item value="Payment" />
      <item value="Minutes" />
      <item value="Creates a string representation of this &lt;tt&gt;Date&lt;tt&gt; object in an implementation-dependent form. The intent is that the form should be familiar to the user of the Java application, wherever it may happen to be running. The intent is comparable to that of the &quot;&lt;code&gt;%c&lt;code&gt;&quot; format supported by the &lt;code&gt;strftime()&lt;code&gt; function of ISO&amp;nbsp;C." />
      <item value="delta" />
      <item value="length" />
      <item value="sharding results for data sources or tables's names" />
      <item value="sharding value" />
      <item value="available data sources or tables's names" />
      <item value="Strategy" />
      <item value="squarely" />
      <item value="Indicates that the persistence provider must assign primary keys for the entity using an underlying database table to ensure uniqueness." />
      <item value="The name of the primary key generator to use as specified in the link SequenceGenerator or link TableGenerator annotation. &lt;p&gt; Defaults to the id generator supplied by persistence provider." />
      <item value="Indicates that the persistence provider should pick an appropriate strategy for the particular database. The &lt;code&gt;AUTO&lt;code&gt; generation strategy may expect a database resource to exist, or it may attempt to create one. A vendor may provide documentation on how to create such resources in the event that it does not support schema generation or cannot create the schema resource at runtime." />
      <item value="Indicates that the persistence provider must assign primary keys for the entity using a database identity column." />
      <item value="Feature that may be enabled to force replacement &lt;code&gt;org.hibernate.collection.spi.PersistentCollection&lt;code&gt;, &lt;code&gt;List&lt;code&gt;, &lt;code&gt;Set&lt;code&gt;, &lt;code&gt;Map&lt;code&gt; subclasses during serialization as standard JDK link java.util.List, link java.util.Set and link java.util.Map. This is usually done to prevent issues with polymorphic handling, so that type id is generated for standard containers and NOT for Hibernate variants. &lt;p&gt;" />
      <item value="This feature determines how link org.hibernate.collection.spi.PersistentCollections properties for which no annotation is found are handled with respect to lazy-loading: if true, lazy-loading is only assumed if annotation is used to indicate that; if false, lazy-loading is assumed to be the default. Note that link #FORCE_LAZY_LOADING has priority over this Feature; meaning that if it is defined as true, setting of this Feature has no effect. &lt;p&gt; Default value is false, meaning that laziness is considered to be the default value." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="568" />
        <entry key="ENGLISH" value="569" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="ITALIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190222000270023" />
      </app-key>
    </option>
    <option name="foldOriginal" value="true" />
    <option name="ignoreRegExp" value="[\/\*\@\{\}]" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Source Code Pro" />
    <option name="primaryFontFamily" value="Microsoft YaHei" />
    <option name="translator" value="fanyi.baidu" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="0b9675ec9310c20e" />
      </youdao-translate>
    </option>
  </component>
</application>