<application>
  <component name="AppStorage">
    <histories>
      <item value="Wrap an object, if necessary. If the object is null, return the NULL object. If it is an array or collection, wrap it in a JSONArray. If it is a map, wrap it in a JSONObject. If it is a standard property (Double, String, et al) then it is already wrapped. Otherwise, if it comes from one of the java packages, turn it into a string. And if it doesn't, try to wrap it in a JSONObject. If the wrapping fails, then null is returned." />
      <item value="Creates a new decompressor. If the parameter 'nowrap' is true then the ZLIB header and checksum fields will not be used. This provides compatibility with the compression format used by both GZIP and PKZIP. Note: When using the 'nowrap' option it is also necessary to provide an extra &quot;dummy&quot; byte as input. This is required by the ZLIB native library in order to support certain optimizations. @param nowrap if true then support GZIP compatible compression" />
      <item value="Creates a new decompressor. If the parameter 'nowrap' is true then the ZLIB header and checksum fields will not be used. This provides compatibility with the compression format used by both GZIP and PKZIP. Note: When using the 'nowrap' option it is also necessary to provide an extra &quot;dummy&quot; byte as input. This is required by the ZLIB native library in order to support certain optimizations." />
      <item value="* Creates a new decompressor. If the parameter 'nowrap' is true then * the ZLIB header and checksum fields will not be used. This provides * compatibility with the compression format used by both GZIP and PKZIP. * &lt;p&gt; * Note: When using the 'nowrap' option it is also necessary to provide * an extra &quot;dummy&quot; byte as input. This is required by the ZLIB native * library in order to support certain optimizations." />
      <item value="Creates a new decompressor. If the parameter 'nowrap' is true then the ZLIB header and checksum fields will not be used. This provides compatibility with the compression format used by both GZIP and PKZIP." />
      <item value="Note: When using the 'nowrap' option it is also necessary to provide * an extra &quot;dummy&quot; byte as input. This is required by the ZLIB native * library in order to support certain optimizations." />
      <item value="Creates a new decompressor. If the parameter 'nowrap' is true then * the ZLIB header and checksum fields will not be used. This provides * compatibility with the compression format used by both GZIP and PKZIP." />
      <item value=" the number of parties currently blocked in await" />
      <item value="Returns the number of parties currently waiting at the barrier. This method is primarily useful for debugging and assertions. " />
      <item value="Returns the number of parties currently waiting at the barrier." />
      <item value="instead" />
      <item value="preferable" />
      <item value="threads need to re-synchronize in some other way,      and choose one to perform the reset.  It may be preferable to instead create a new barrier for subsequent use" />
      <item value="Note that resets after a breakage has occurred for other reasons can be complicated to  carry out; " />
      <item value="Resets the barrier to its initial state. If any parties are * currently waiting at the barrier, they will return with a * {@link BrokenBarrierException}. Note that resets &lt;em&gt;after&lt;/em&gt; * a breakage has occurred for other reasons can be complicated to * carry out; threads need to re-synchronize in some other way, * and choose one to perform the reset. It may be preferable to * instead create a new barrier for subsequent use." />
      <item value="if one or more parties broke out of this * barrier due to interruption or timeout since * construction or the last reset, or a barrier action * failed due to an exception; {@code false} otherwise" />
      <item value="Queries if this barrier is in a broken state." />
      <item value="Returns the number of parties required to trip this barrier." />
      <item value="This method is typically used for debugging and testing purposes" />
      <item value="Returns the current count" />
      <item value="is interrupted while waiting" />
      <item value="while waiting" />
      <item value="has its interrupted status set on entry to this method" />
      <item value="The count reaches zero due to invocations of the * {@link #countDown} method" />
      <item value="If the current count is greater than zero then the current * thread becomes disabled for thread scheduling purposes and lies * dormant until one of two things happen" />
      <item value="/** * Causes the current thread to wait until the latch has counted down to * zero, unless the thread is {@linkplain Thread#interrupt interrupted}. * * &lt;p&gt;If the current count is zero then this method returns immediately. * * &lt;p&gt;If the current count is greater than zero then the current * thread becomes disabled for thread scheduling purposes and lies * dormant until one of two things happen: * &lt;ul&gt; * &lt;li&gt;The count reaches zero due to invocations of the * {@link #countDown} method; or * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts} * the current thread. * &lt;/ul&gt; * * &lt;p&gt;If the current thread: * &lt;ul&gt; * &lt;li&gt;has its interrupted status set on entry to this method; or * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while waiting, * &lt;/ul&gt; * then {@link InterruptedException} is thrown and the current thread's * interrupted status is cleared. * * @throws InterruptedException if the current thread is interrupted * while waiting" />
      <item value="/** * Decrements the count of the latch, releasing all waiting threads if * the count reaches zero. * * &lt;p&gt;If the current count is greater than zero then it is decremented. * If the new count is zero then all waiting threads are re-enabled for * thread scheduling purposes. * * &lt;p&gt;If the current count equals zero then nothing happens. */" />
      <item value="Inserts the specified element into this priority queue. * As the queue is unbounded, this method will never block or * return {@code false}. * * @param e the element to add * @param timeout This parameter is ignored as the method never blocks * @param unit This parameter is ignored as the method never blocks * @return {@code true} (as specified by * {@link BlockingQueue#offer(Object,long,TimeUnit) BlockingQueue.offer}) * @throws ClassCastException if the specified element cannot be compared * with elements currently in the priority queue according to the * priority queue's ordering * @throws NullPointerException if the specified element is null" />
      <item value="A {@link SortedMap} extended with navigation methods returning the * closest matches for given search targets. Methods * {@code lowerEntry}, {@code floorEntry}, {@code ceilingEntry}, * and {@code higherEntry} return {@code Map.Entry} objects * associated with keys respectively less than, less than or equal, * greater than or equal, and greater than a given key, returning * {@code null} if there is no such key. Similarly, methods * {@code lowerKey}, {@code floorKey}, {@code ceilingKey}, and * {@code higherKey} return only the associated keys. All of these * methods are designed for locating, not traversing entries. * * &lt;p&gt;A {@code NavigableMap} may be accessed and traversed in either * ascending or descending key order. The {@code descendingMap} * method returns a view of the map with the senses of all relational * and directional methods inverted. The performance of ascending * operations and views is likely to be faster than that of descending * ones. Methods {@code subMap}, {@code headMap}, * and {@code tailMap} differ from the like-named {@code * SortedMap} methods in accepting additional arguments describing * whether lower and upper bounds are inclusive versus exclusive. * Submaps of any {@code NavigableMap} must implement the {@code * NavigableMap} interface." />
      <item value="/** * Returns a canonical representation for the string object. * &lt;p&gt; * A pool of strings, initially empty, is maintained privately by the * class {@code String}. * &lt;p&gt; * When the intern method is invoked, if the pool already contains a * string equal to this {@code String} object as determined by * the {@link #equals(Object)} method, then the string from the pool is * returned. Otherwise, this {@code String} object is added to the * pool and a reference to this {@code String} object is returned. * &lt;p&gt; * It follows that for any two strings {@code s} and {@code t}, * {@code s.intern() == t.intern()} is {@code true} * if and only if {@code s.equals(t)} is {@code true}. * &lt;p&gt; * All literal strings and string-valued constant expressions are * interned. String literals are defined in section 3.10.5 of the * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;. * * @return a string that has the same contents as this string, but is * guaranteed to be from a pool of unique strings. */" />
      <item value="html" />
      <item value="signifying" />
      <item value="SIZED" />
      <item value="/** * Characteristic value signifying that the value returned from * {@code estimateSize()} prior to traversal or splitting represents a * finite size that, in the absence of structural source modification, * represents an exact count of the number of elements that would be * encountered by a complete traversal. * * @apiNote Most Spliterators for Collections, that cover all elements of a * {@code Collection} report this characteristic. Sub-spliterators, such as * those for {@link HashSet}, that cover a sub-set of elements and * approximate their reported size do not. */" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="6" />
        <entry key="ENGLISH" value="7" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="foldOriginal" value="true" />
    <option name="ignoreRegExp" value="[\*]|(&lt;p&gt;)" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Source Code Pro" />
    <option name="primaryFontFamily" value="Microsoft YaHei" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="0b9675ec9310c20e" />
      </youdao-translate>
    </option>
  </component>
</application>