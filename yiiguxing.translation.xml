<application>
  <component name="AppStorage">
    <histories>
      <item value="the protocol (scheme) the annotated string must match, e.g. ftp or http. Per default any protocol is allowed" />
      <item value="Creates a localized description of this throwable. Subclasses may override this method in order to produce a locale-specific message. For subclasses that do not override this method, the default implementation returns the same result as code getMessage()." />
      <item value="Proving" />
      <item value="charsToDelete a set of characters to delete, in addition to trimming an input String. Useful for deleting unwanted line breaks: e.g. &quot;\r\n\f&quot; will delete all new lines and line feeds in a String." />
      <item value="Whether user credentials are supported. &lt;p&gt;By default this is not set (i.e. user credentials are not supported)." />
      <item value="Indicates that a class declares one or more link Bean Bean methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime, for example:" />
      <item value="Interface to be implemented by any object that wishes to be notified of the link ApplicationContext that it runs in. &lt;p&gt;Implementing this interface makes sense for example when an object requires access to a set of collaborating beans. Note that configuration via bean references is preferable to implementing this interface just for bean lookup purposes. &lt;p&gt;This interface can also be implemented if an object needs access to file resources, i.e. wants to call code getResource, wants to publish an application event, or requires access to the MessageSource. However, it is preferable to implement the more specific link ResourceLoaderAware, link ApplicationEventPublisherAware or link MessageSourceAware interface in such a specific scenario. &lt;p&gt;Note that file resource dependencies can also be exposed as bean properties of type link org.springframework.core.io.Resource, populated via Strings with automatic type conversion by the bean factory. This removes the need for implementing any callback interface just for the purpose of accessing a specific file resource. &lt;p&gt;link org.springframework.context.support.ApplicationObjectSupport is a convenience base class for application objects, implementing this interface. &lt;p&gt;For a list of all bean lifecycle methods, see the link org.springframework.beans.factory.BeanFactory BeanFactory javadocs." />
      <item value="The Generated annotation is used to mark source code that has been generated. It can also be used to differentiate user written code from generated code in a single file. When used, the value element must have the name of the code generator. The recommended convention is to use the fully qualified name of the code generator in the value field . &lt;p&gt;For example: com.company.package.classname. The date element is used to indicate the date the source was generated. The date element must follow the ISO 8601 standard. For example the date element would have the following value 2001-07-04T12:08:56.235-0700 which represents 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.&lt;p&gt; &lt;p&gt;The comment element is a place holder for any comments that the code generator may want to include in the generated code.&lt;p&gt;" />
      <item value="delta" />
      <item value="Increment an integer value stored as string value under code key by code delta." />
      <item value="Set code value of code key and return its old value." />
      <item value="proving" />
      <item value="the amount to add, may be negative" />
      <item value="Name of the target database to operate on, auto-detected by default. Can be alternatively set using the &quot;Database&quot; enum." />
      <item value="On input: an alignment field, if desired. On output: the offsets of the alignment field. For example, given a time text &quot;1996.07.10 AD at 15:08:56 PDT&quot;, if the given fieldPosition is DateFormat.YEAR_FIELD, the begin index and end index of fieldPosition will be set to 0 and 4, respectively. Notice that if the same time field appears more than once in a pattern, the fieldPosition will be set for the first occurrence of that time field. For instance, formatting a Date to the time string &quot;1 PM PDT (Pacific Daylight Time)&quot; using the pattern &quot;h a z (zzzz)&quot; and the alignment field DateFormat.TIMEZONE_FIELD, the begin index and end index of fieldPosition will be set to 5 and 8, respectively, for the first occurrence of the timezone pattern character 'z'. return the string buffer passed in as toAppendTo, with formatted text appended." />
      <item value="Formats a Date into a datetime string. param date a Date to be formatted into a datetime string. param toAppendTo the string buffer for the returning datetime string. param fieldPosition keeps track of the position of the field" />
      <item value="Whether link javax.persistence.Transient annotation should be checked or not; if true, will consider code Transient to mean that property is to be ignored; if false annotation will have no effect." />
      <item value="Using link #FORCE_LAZY_LOADING may result in `javax.persistence.EntityNotFoundException`. This flag configures Jackson to ignore the error and serialize a `null`." />
      <item value="Default setting is false, so that no replacement occurs." />
      <item value="Feature that may be enabled to force replacement &lt;code&gt;org.hibernate.collection.spi.PersistentCollection&lt;code&gt;, &lt;code&gt;List&lt;code&gt;, &lt;code&gt;Set&lt;code&gt;, &lt;code&gt;Map&lt;code&gt; subclasses during serialization as standard JDK link java.util.List, link java.util.Set and link java.util.Map. This is usually done to prevent issues with polymorphic handling, so that type id is generated for standard containers and NOT for Hibernate variants." />
      <item value="This feature determines how link org.hibernate.collection.spi.PersistentCollections properties for which no annotation is found are handled with respect to lazy-loading: if true, lazy-loading is only assumed if annotation is used to indicate that; if false, lazy-loading is assumed to be the default. Note that link #FORCE_LAZY_LOADING has priority over this Feature; meaning that if it is defined as true, setting of this Feature has no effect." />
      <item value="If FORCE_LAZY_LOADING is false, this feature serializes uninitialized lazy loading proxies as &lt;code&gt;&quot;identifierName&quot;:&quot;identifierValue&quot;&lt;code&gt; rather than &lt;code&gt;null&lt;code&gt;. &lt;p&gt;" />
      <item value="Whether lazy-loaded object should be forced to be loaded and then serialized (true); or serialized as nulls (false)." />
      <item value="&lt;li&gt;The method MUST NOT have any parameters except in the case of interceptors in which case it takes an InvocationContext object as defined by the Interceptors specification.&lt;li&gt; &lt;li&gt;The method defined on an interceptor class MUST HAVE one of the following signatures: &lt;p&gt;" />
      <item value="The PostConstruct annotation is used on a method that needs to be executed after dependency injection is done to perform any initialization. This method MUST be invoked before the class is put into service. This annotation MUST be supported on all classes that support dependency injection. The method annotated with PostConstruct MUST be invoked even if the class does not request any resources to be injected. Only one method can be annotated with this annotation. The method on which the PostConstruct annotation is applied MUST fulfill all of the following criteria:" />
      <item value="Build a new link ObjectMapper instance. &lt;p&gt;Each build operation produces an independent link ObjectMapper instance. The builder's settings can get modified, with a subsequent build operation then producing a new link ObjectMapper based on the most recent settings. return the newly built ObjectMapper" />
      <item value="If set to code true, an link XmlMapper will be created using its default constructor. This is only applicable to link #build() calls, not to link #configure calls." />
      <item value="the target type of the join" />
      <item value="the source type of the join" />
      <item value="Specify whether this resolver's cookies should be compliant with BCP 47 language tags instead of Java's legacy locale specification format. &lt;p&gt;The default is code true, as of 5.1. Switch this to code false for rendering Java's legacy locale specification format. For parsing, this resolver leniently accepts the legacy link Locale#toString format as well as BCP 47 language tags in any case." />
      <item value="Specify whether to reject cookies with invalid content (e.g. invalid format). &lt;p&gt;The default is code true. Turn this off for lenient handling of parse failures, falling back to the default locale and time zone in such a case." />
      <item value="Set whether to ignore an invalid value for the locale parameter." />
      <item value="The headers of the mapped request, narrowing the primary mapping. &lt;p&gt;Same format for any environment: a sequence of &quot;My-Header=myValue&quot; style expressions, with a request only mapped if each such header is found to have the given value. Expressions can be negated by using the &quot;!=&quot; operator, as in &quot;My-Header!=myValue&quot;. &quot;My-Header&quot; style expressions are also supported, with such headers having to be present in the request (allowed to have any value). Finally, &quot;!My-Header&quot; style expressions indicate that the specified header is &lt;i&gt;not&lt;i&gt; supposed to be present in the request. &lt;p&gt;Also supports media type wildcards (), for headers such as Accept and Content-Type. For instance, &lt;pre class=&quot;code&quot;&gt; &amp;#064;RequestMapping(value = &quot;something&quot;, headers = &quot;content-type=text&quot;) &lt;pre&gt; will match requests with a Content-Type of &quot;texthtml&quot;, &quot;textplain&quot;, etc. &lt;p&gt;&lt;b&gt;Supported at the type level as well as at the method level!&lt;b&gt; When used at the type level, all method-level mappings inherit this header restriction (i.e. the type-level restriction gets checked before the handler method is even resolved)." />
      <item value="When the javax.persistence.fetchgraph property is used to specify an entity graph, attributes that are specified by attribute nodes of the entity graph are treated as FetchType.EAGER and attributes that are not specified are treated as FetchType.LAZY" />
      <item value="When the javax.persistence.loadgraph property is used to specify an entity graph, attributes that are specified by attribute nodes of the entity graph are treated as FetchType.EAGER and attributes that are not specified are treated according to their specified or default FetchType." />
      <item value="Register OpenEntityManagerInViewInterceptor. Binds a JPA EntityManager to the thread for the entire processing of the request." />
      <item value="tuple" />
      <item value="(Optional) The name of the entity graph. Defaults to the entity name of the root entity." />
      <item value="The paths of attributes of this link EntityGraph to use, empty by default. You can refer to direct properties of the entity or nested properties via a code property.nestedProperty." />
      <item value="The name of the EntityGraph to use. If empty we fall-back to link JpaQueryMethod#getNamedQueryName() as the value." />
      <item value="Annotation to configure the JPA 2.1 link javax.persistence.EntityGraphs that should be used on repository methods. Since 1.9 we support the definition of dynamic link EntityGraphs by allowing to customize the fetch-graph via via link #attributePaths() ad-hoc fetch-graph configuration." />
      <item value="unless" />
      <item value="Returns a collection containing all the elements in &lt;code&gt;collection&lt;code&gt; that are also in &lt;code&gt;retain&lt;code&gt;. The cardinality of an element &lt;code&gt;e&lt;code&gt; in the returned collection is the same as the cardinality of &lt;code&gt;e&lt;code&gt; in &lt;code&gt;collection&lt;code&gt; unless &lt;code&gt;retain&lt;code&gt; does not contain &lt;code&gt;e&lt;code&gt;, in which case the cardinality is zero. This method is useful if you do not wish to modify the collection &lt;code&gt;c&lt;code&gt; and thus cannot call &lt;code&gt;c.retainAll(retain);&lt;code&gt;. &lt;p&gt;" />
      <item value="Annotation used to indicate that associated property is part of two-way linkage between fields; and that its role is &quot;child&quot; (or &quot;back&quot;) link. Value type of the property must be a bean: it can not be a Collection, Map, Array or enumeration. Linkage is handled such that the property annotated with this annotation is not serialized; and during deserialization, its value is set to instance that has the &quot;managed&quot; (forward) link. &lt;p&gt; All references have logical name to allow handling multiple linkages; typical case would be that where nodes have both parentchild and sibling linkages. If so, pairs of references should be named differently. It is an error for a class to have multiple back references with same name, even if types pointed are different. &lt;p&gt; Note: only methods and fields can be annotated with this annotation: constructor arguments should NOT be annotated, as they can not be either managed or back references." />
      <item value="Use an outer join to load the related entities, collections or joins." />
      <item value="Use a secondary select for each individual entity, collection, or join load." />
      <item value="Fetch options on associations. Defines more of the &quot;how&quot; of fetching, whereas JPA link javax.persistence.FetchType focuses on the &quot;when&quot;." />
      <item value="Available for collections only.  When accessing a non-initialized collection, this fetch mode will trigger loading all elements of all collections of the same role for all owners associated with the persistence context using a single secondary select." />
      <item value="(Optional) The name of the primary key generator to use as specified in the link SequenceGenerator or link TableGenerator annotation. &lt;p&gt; Defaults to the id generator supplied by persistence provider." />
      <item value="Specifies a composite primary key class that is mapped to multiple fields or properties of the entity. &lt;p&gt; The names of the fields or properties in the primary key class and the primary key fields or properties of the entity must correspond and their types must be the same." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="492" />
        <entry key="ENGLISH" value="493" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="ITALIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190222000270023" />
      </app-key>
    </option>
    <option name="foldOriginal" value="true" />
    <option name="ignoreRegExp" value="[\/\*\@\{\}]" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Source Code Pro" />
    <option name="primaryFontFamily" value="Microsoft YaHei" />
    <option name="translator" value="fanyi.baidu" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="0b9675ec9310c20e" />
      </youdao-translate>
    </option>
  </component>
</application>